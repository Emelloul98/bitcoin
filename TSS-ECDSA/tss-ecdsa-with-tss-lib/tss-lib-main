package main

import (
	"crypto/ecdsa"
  "crypto/sha256"
	"encoding/hex"
	"fmt"
	"math/big"
	"runtime"
	"sync/atomic"
	"testing"
  "golang.org/x/crypto/ripemd160"

	"github.com/ipfs/go-log"
	"github.com/stretchr/testify/assert"

	"github.com/bnb-chain/tss-lib/v2/common"
	"github.com/bnb-chain/tss-lib/v2/ecdsa/keygen"
	"github.com/bnb-chain/tss-lib/v2/test"
	"github.com/bnb-chain/tss-lib/v2/tss"
)

const (
	testParticipants = 5
	testThreshold    = 3
)
func main() {
	ids := []string{"party1", "party2", "party3"}
	threshold := 2
	parties := tss.SortPartyIDs(makePartyIDs(ids))
	partyIDMap := make(map[string]*tss.PartyID)
	for _, id := range parties {
		partyIDMap[id.Id] = id
	}
	preParams, _ := keygen.GeneratePreParams(1 * time.Minute)
	keygenOutChs := make([]chan tss.Message, len(parties))
	keygenEndChs := make([]chan *keygen.LocalPartySaveData, len(parties))
	for i := 0; i < len(parties); i++ {
		params := tss.NewParameters(tss.Edwards(), tss.NewPeerContext(parties), parties[i], len(parties), threshold)
		party := keygen.NewLocalParty(params, keygenOutChs[i], keygenEndChs[i], preParams)
		go func(p tss.Party) {
			if err := p.Start(); err != nil {
				fmt.Println("Error:", err)
				return
			}
		}(party)
	}
	keygenSaveData := make([]*keygen.LocalPartySaveData, len(parties))
	for i := 0; i < len(parties); i++ {
		keygenSaveData[i] = <-keygenEndChs[i]
		saveKeyToFile(fmt.Sprintf("party%d_key.txt", i+1), keygenSaveData[i])
	}
}




